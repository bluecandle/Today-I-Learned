<a href ='https://www.44bits.io/ko/post/is-docker-container-a-virtual-machine-or-a-process'>source</a>

# 도커 컨테이너는 가상머신인가요? 프로세스인가요?
가상머신은 운영체제 위에 하드웨어를 에뮬레이션하고 그 위에 운영체제를 올리고 프로세스를 실행하는 반면에, 도커 컨테이너는 하드웨어 에뮬레이션 없이 리눅스 커널을 공유해서 바로 프로세스를 실행한다

그리고 uname -a의 출력 결과가 동일하다는 것도 재미있습니다. 서로 다른 환경에서 컨테이너가 실행되었지만 커널이 같다는 것에 주목해주세요.

맥OS는 리눅스가 아니므로 네이티브하게 도커를 사용할 수 없습니다. 따라서 도커 데스크탑은 리눅스킷 기반 경량 가상머신 위에서 도커를 실행합니다. 어쨌건 재미있는 사실을 확인했습니다. 우분투 18.04에서 실행한 컨테이너가 사용하는 커널과 맥OS의 도커 데스크탑에서 실행한 컨테이너에서 사용하는 커널은 다릅니다.

### 리눅스킷
https://github.com/linuxkit/linuxkit
A toolkit for building secure, portable and lean operating systems for containers

컨테이너는 호스트 시스템의 커널을 사용한다.
컨테이너는 이미지에 따라서 실행되는 환경(파일 시스템)이 달라진다.

일반적으로 리눅스에서 1번 프로세스는 init 프로세스로 특별한 의미를 가지고 있습니다. 실제로 호스트 상에서 pstree를 실행해보면 모든 프로세스가 1번 프로세스(systemd)에 물려있는 것을 확인할 수 있습니다.

## ??! 왜 1번 프로세스??
컨테이너는 프로세스지만, 프로세스라고 부르기보다는 컨테이너라고 부르는 데는 이유가 있는 법입니다. 컨테이너는 (주로) 리눅스 커널에 포함된 프로세스 격리 기술들을 사용해서 생성된 특별한 프로세스입니다. 처음 도커를 보면 가상머신이라고 느끼는 건 바로 이런 이유 때문입니다. 예를 들어 앞선 예제에서 bash 명령어로 마치 컨테이너라는 가상머신에 접속해서 명령어를 실행하는 것처럼 느껴집니다만, 사실 bash는 가상머신에 접속하는 명령어가 아니라 그냥 호스트 상에서는 프로세스일 뿐입니다. 그런데 PID가 1인 특별한 bash 프로세스입니다 (?!). 어떻게 하나의 하늘 아래 두 개의 태양(1번 프로세스)이 존재할 수 있을까요.

# PID 1번의 비밀, 도커 없이 일반 프로세스의 PID를 1번으로 실행하기
어떻게 이게 가능한 걸까요? 이를 구현하는 데 사용된 기능이 바로 리눅스 네임스페이스입니다. 정확히는 PID 네임스페이스가 분리되어있기 때문에 도커 컨테이너의 프로세스는 1번이 됩니다. 도커 없이도 unshare 명령어로 프로세스의 PID 네임스페이스를 분리해볼 수 있습니다.

PID 네임스페이스를 제대로 분리해보기 위해서는 독자적인 환경이 필요합니다. chroot 글에서 자세히 다루고 있습니다만, 루트 디렉터리를 바꿔서 프로세스를 실행한다는 게 생각보다 간단한 일은 아닙니다. 독자적인 환경에는 프로세스를 실행하기 위한 모든 파일들이 준비되어있어야합니다. 직접 준비하는 것도 가능하지만, 도커 이미지를 복사해오는 게 가장 간단합니다. 

# 2개의 PID: 프로세스가 바라보는 프로세스 ID, 호스트가 바라보는 프로세스 ID
즉, 프로세스에게는 자신의 PID가 1번으로 보이지만, 호스트 입장에서는 PID가 2387인 일반적인 프로세스라는 의미입니다.

## 프로세스 ID를 격리하는 PID 네임스페이스
PID 네임스페이스라는 게, 이렇게 보니까 아주 생소하게 느껴집니다만 사실 모든 프로세스는 PID 네임스페이스를 가지고 있습니다. 리눅스 시스템에 대해서 공부해보신 분이라면, /proc 디렉터리에 시스템과 프로세스에 대한 정보가 담겨져있다는 것을 알고 계실 겁니다. 호스트 상에서  /proc 디렉터리로 이동해보면 프로세스 아이디 이름을 가진 디렉터리들이 옹기종기 모여 있습니다.

모든 프로세스 디렉터리 아래에는 ns라는 디렉터리가 있는데 여기서 ns가 바로 네임스페이스를 줄인 단어입니다

자세히 보면 pid:[4026531836]에 10자리 숫자가 적혀있습니다. 바로 이 숫자가 현재 프로세스의 PID 네임스페이스입니다. systemd는  4026531836 PID 네임스페이스의 첫번째 프로세스이며 PID는 1번입니다. 기본적으로 모든 프로세스는 init 프로세스의 네임스페이스를 그대로 공유합니다.

# 도커 컨테이너는 정말로 프로세스인가요?
/var/lib/docker 디렉터리의 내용을 뒤적여보았습니다. 이번에는 /var/run/docker 아래의 내용을 살펴봅니다.

    $ cd /var/run/docker/runtime-runc/moby/
    $ ls
    622eb0c2acac4d6c9304e57dcc8ea83fdaec31020ce124e281942dc44ee30725
앞서 실행한 nginx 컨테이너로 추정되는 디렉터리가 보이네요. 컨테이너 아이디와 앞부분이 같습니다. 이 디렉터리 안에는 state.json 파일이 하나 있습니다. 내용이 꽤 많아서 여기서는 jq로 필요한 부분만 추출해보겠습니다.*

* jq는 커맨드라인에서 JSON 파일 내용을 바로 프로세싱할 수 있는 도구입니다. 우분투에서는 apt install jq로 설치할 수 있습니다. 더 자세한 내용은 커맨드라인 JSON 프로세서 jq : 기초 문법과 작동원리 글을 참고해주세요.

어떤가요, 이제 확실해졌죠? 컨테이너는 그냥 프로세스였습니다. 좀 더 정확히는 호스트 입장에서는 컨테이너도 그냥하나의 프로세스에 불과합니다.

# 결론
도커 컨테이너가 프로세스라는 걸 정확히 이해하면 도커 이미지를 ’단 하나의 타깃 프로세스를 실행하기 위한 파일들의 집합’으로 이해할 수 있게됩니다. docker exec 명령어도 SSH 접속이나 가상머신에서 셸을 실행하는 것이 아니라, 컨테이너가 사용중인 네임스페이스나 파일 시스템에 접근하기 위한 특별한 명령어에 불과하다는 것을 알 수 있습니다.

# 리눅스 컨테이너란?
키워드, 2020-01-23 - 리눅스 컨테이너는 운영체제 수준의 가상화 기술로 리눅스 커널을 공유하면서 프로세스를 격리된 환경에서 실행하는 기술을 의미합니다. 하드웨어를 가상화하는 가상 머신과 달리 커널을 공유하는 방식이기 때문에 실행 속도가 빠르고, 성능 상의 손실이 거의 없다는 장점이 있습니다.

---
https://www.44bits.io/ko/post/is-docker-container-a-virtual-machine-or-a-process
https://www.44bits.io/ko/post/static-compile-program-on-chroot-and-docker-scratch-image
이거도 살펴보자.