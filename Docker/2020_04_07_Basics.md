찬규 추천!

# 왜 굳이 도커(컨테이너)를 써야 하나요? 눈송이 서버의 한계를 넘어 컨테이너를 사용해야 하는 이유
## source
<a href = 'https://www.44bits.io/ko/post/why-should-i-use-docker-container'>https://www.44bits.io/ko/post/why-should-i-use-docker-container</a>

그러나 컨테이너 도구인 도커Docker가 설치되어 있다면 어느 환경이든 상관 없이 다음 명령어를 사용하여 깃랩을 실행할 수 있습니다. (이 명령도 간단해보이진 않겠지만, 그저 운영체제별로 존재하는 복잡한 설치 과정을 겪지 않는다는 점만 기억하시면 됩니다.)

    $ docker run --detach \
        --hostname gitlab.example.com \
        --publish 443:443 --publish 80:80 --publish 22:22 \
        --name gitlab \
        --restart always \
        --volume /srv/gitlab/config:/etc/gitlab \
        --volume /srv/gitlab/logs:/var/log/gitlab \
        --volume /srv/gitlab/data:/var/opt/gitlab \
        gitlab/gitlab-ce:latest

## 도커 없이도 배포/운영하고 있는데, 우린 아무 불편을 느끼지 못합니다.왜 도커를 써야 하죠?

### 운영하면서 만들어지는 눈송이 서버들(Snowflake Servers)
처음 들어가는 서버에서는 마음 먹은 대로 문제를 해결하기가 어렵습니다. 각 서버마다 운영 기록이 다르기 때문입니다. 똑같은 일을 하는 두 서버가 있다 해도, A 서버는 한 달 전에 구성했고 B 서버는 이제 막 구성했다면, 운영체제부터 컴파일러, 설치된 패키지까지 완벽하게 같기는 쉽지 않습니다. 그리고 이러한 차이점들이 장애를 일으키고 말죠. A 서버는 잘 되는데 B 서버는 왜 죽었지?와 같은 일(혹은 그 반대)이 벌어지는 겁니다. 이렇게 서로 모양이 다른 서버들이 존재하는 상황을 눈송이 서버(Snowflakes Server)이라고도 합니다.

### 서버를 코드로 구성하고 관리하는 다양한 방법
이런 상황을 개선하고자 다양한 방식으로 서버 운영 기록을 저장해 두곤 합니다. 가장 흔하게는 서버에서 어떤 작업을 실행할 때마다 이를 사내 문서 도구에 기록해둔다거나, 여러 서버에 동시 접속해서 한꺼번에 명령을 실행하는 tmux-xpanes 같은 도구를 사용하기도 하죠.
(https://github.com/greymd/tmux-xpanes)

### 도커 파일, 이미지
    Nginx 서버를 구성하는 도커 파일
    FROM debian:stretch-slim

    RUN apt-get update \
        && apt-get install -y \
        imagemagick  

이 도커 파일로 도커 이미지를 만들 수 있습니다. 도커 파일이 서버 운영 기록이라면, 도커 이미지는 운영 기록을 실행할 시점이라고 할 수 있습니다.

도커 파일 = 서버 운영 기록 코드화
도커 이미지 = 도커 파일 + 실행 시점

### 테스트 주도 개발
소프트웨어 작성에 도움을 주는 기법 중 하나인 테스트 주도 개발Test Driven Development은 이미 잘 아실 겁니다.

    1. TDD에서는 먼저 테스트를 작성하고,
    2. 테스트에 실패하고,
    3. 코드를 작성/수정한 후,
    4. 테스트를 성공합니다.
    5. 중복된 코드 등을 리팩터링합니다.
    6. 1번으로 돌아갑니다.

도커 파일도 같은 맥락에서 생각해보면

    1. 도커 파일을 만들고
    2. 도커 이미지 만들기에 실패하고,
    3. 도커 파일을 작성/수정한 후,
    4. 도커 이미지 만드는 데 성공합니다.
    5. 필요 없는 부분은 지우고 합칠 수 있는 명령은 합칩니다. (=효율화)
    6. 1번으로 돌아갑니다.

* 한 가지 팁을 이야기하자면 기반 이미지로 컨테이너를 하나 실행한 다음 거기서 원하는 명령어들을 입력하고 원하는 결과가 나왔을 때 해당 명령어를 도커 파일로 옮기는 식으로 작업하면 실패 -> 수정 과정을 훨씬 더 빨리 반복할 수 있습니다.

## 클래스와 인스턴스처럼 도커 이미지 바라보기
지금까지 서버를 똑같이 만드는 데 노력을 기울였지만, 사실 서버에는 바뀌어야 할 부분도 있습니다. 일례로 한 컴퓨터에서 A라는 도커 컨테이너를 두 개 배포했다면, 이 둘을 어떻게 구분할까요? 도커에서는 내부 규칙에 따라 해시 값(=컨테이너 id)과 임의의 이름(=컨테이너 이름)을 붙입니다. 물론 IP도 다르고요. 도커에서는 이렇게 바뀌어야 할 부분을 환경변수에 넣고 관리하도록 권합니다. 이러한 도커 이미지의 특징은, 소프트웨어 분야의 클래스와 public 변수, private 변수에 비견할 수 있습니다.

### 도커 파일, 이미지, 컨테이너
도커 파일에 실행 시점을 더한 것이 도커 이미지라면, 도커 이미지에 실행 시점에 수정되어야 할 정보들을 더한 것이 도커 컨테이너입니다.

    도커 파일 == 서버 운영 기록
    도커 이미지 == 도커 파일 + 실행 시점
    도커 컨테이너 == 도커 이미지 + 환경 변수

## 서버 코드화의 장점

    1. 서버 제작 과정에 견고함과 유연성을 더할 뿐 아니라
    2. 다른 이가 만든 서버를 소프트웨어 사용하듯 가져다 쓸 수 있고
    3. 여러 대에 배포할 수 있는 확장성

# 도커(Docker) 입문편 컨테이너 기초부터 서버 배포까지

## source
<a href = 'https://www.44bits.io/ko/post/easy-deploy-with-docker#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0'>https://www.44bits.io/ko/post/easy-deploy-with-docker#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0</a>

## 시작하며
컨테이너가 실행되고 있는 호스트 입장에서 컨테이너는 단순히 프로세스에 불과합니다만, 사용자나 컨테이너 입장에서는 호스트와는 무관하게 동작하는 가상머신처럼 보입니다. 그래서 컨테이너형 가상화라고 부르기도 합니다. 도커는 이러한 컨테이너 형 가상화를 지원하는 도구 중 하나입니다. 
이는 가상머신과 같이 하드웨어를 가상화하는 것이 아니라, 운영체제 상에서 지원하는 방법을 통해서 하나의 프로세스(컨테이너)를 실행하기 위한 별도의 환경을 구축하는 일을 지원하고, 도커는 바로 프로세스를 격리시켜 실행해주는 도구라고 할 수 있습니다.

### 도커의 패키지 구성
도커 패키지는 원래 docker-engine 하나였습니다만 현재는 docker-ce와 docker-ce-cli 두 가지로 나눠져 있습니다. 여기서 ce는 커뮤니티 에디선Community Edition의 줄임말입니다. 패키지가 나눠져있는 이유를 이해하려면 도커의 아키텍처에 대해서 알아야 합니다. 도커는 크게 도커 엔진과 클라이언트로 나뉩니다. 도커 엔진은 서버로 동작하며, 시스템 상에 서비스로 등록 됩니다. 도커 클라이언트는 사용자가 입력하는 docker 명령어입니다. 이 명령어를 실행하면 클라이언트는 도커 서버에 명령을 전달하고, 명령은 전적으로 서버에서 처리됩니다. 도커 클라이언트로 외부의 도커 서버에 명령을 내리는 것도 가능합니다. 이러한 아키텍처를 반영해 도커 엔진과 도커 클라이언트 패키지가 나눠졌습니다. 도커 설치에 대한 더 자세한 내용은 Get Docker Engine 공식 문서를 참고해주세요.

### docker ps
docker ps는 앞으로 자주 사용할 명령어 중 하나로, 현재 실행중인 모든 컨테이너 목록을 출력하라는 명령어입니다. 하지만 도커 데몬에 연결할 수 없다는 에러 메시지가 나옵니다. 앞서 얘기했듯이 도커를 설치하는 순간 도커 서비스도 같이 실행됩니다. 일반적으로 이러한 에러가 발생하는 이유는 사용자에게 도커 소켓에 접근할 권한이 없기 때문입니다. 관리자 권한이 있는 경우 명령어 앞에 sudo를 붙이면 정상적으로 실행될 것입니다.

## 도커 이미지
이미지는 가상머신에서 사용하는 이미지와 비슷한 역할을 합니다. 한 마디로 정의해보자면 이미지는 어떤 애플리케이션을 실행하기 위한 환경이라고 할 수 있습니다. 그리고 이 환경은 파일들의 집합입니다. 도커에서는 애플리케이션을 실행하기 위한 파일들을 모아놓고, 애플리케이션과 함께 이미지로 만들 수 있습니다. 그리고 이 이미지를 기반으로 애플리케이션을 바로 배포할 수 있습니다.

이미지 이름은 :을 구분자로 이미지 이름과 태그로 구분됩니다. 태그를 지정하지 않으면 기본값으로 latest가 사용됩니다.


## 도커 허브(Docker Hub) - 공식 이미지 레지스트리

## 컨테이너(Container) 이해하기 - 격리된 환경에서 실행되는 프로세스
 이미지는 어떤 환경이 구성되어있는 상태를 저장해놓은 파일 집합이라고 이야기했습니다. 바로 이 이미지의 환경 위에서 특정한 프로세스를 격리시켜 실행한 것을 컨테이너라고 부릅니다. 컨테이너를 실행하려면 반드시 이미지가 있어야합니다. 다시 한 번 정리합니다. 이미지는 파일들의 집합이고, 컨테이너는 이 파일들의 집합 위에서 실행된 특별한 프로세스입니다.

    * 셸은 대화형으로 리눅스 머신에 명령을 실행하기 위한 커맨드라인 도구입니다. 프로세스이기 때문에 셀을 종료하면, 그걸로 끝입니다. 반면에 SSH는 외부에서 접속하기 위해 설치해두는 서버 프로세스입니다. 따라서 SSH 서버에 접속해서 셸을 사용하고 종료하더라도 SSH 서버는 그대로 살아서 다른 접속을 기다립니다. 겉보기에는 비슷하지만 도커로 셸을 직접 실행해서 사용하는 것과 외부 서버에 SSH로 접속하는 것의 차이를 명확하게 이해해야 도커 컨테이너와 가상머신이 헷갈리지 않을 수 있습니다.

가상머신이 컴퓨터라면, 컨테이너는 단지 격리된 프로세스에 불과합니다. 보통 도커 컨테이너를 처음 다루는 예제에서 셸을 많이 다루기 때문에 컨테이너가 마치 가상머신처럼 보이는 착각을 일으킵니다. 다시 한 번 강조합니다. 컨테이너는 가상머신이라기보다는 프로세스입니다. 이 사실을 꼭 기억해주시기 바랍니다.

이제 ubuntu:bionic 이미지에 깃이 설치된 새로운 이미지를 생성해보도록하겠습니다. 이 또한 VCS와 매우 비슷합니다. 도커에서는 이 작업을 commit이라고 합니다.

이미지 만들기 별 거 없죠? 단지 커밋을 하고 뒤에 이름을 붙여주면 바로 새로운 도커 이미지가 생성됩니다. 이미지로부터 컨테이너를 실행시키고 이 컨테이너의 수정사항을 통해서 새로운 이미지를 만들었습니다.

하나 알아두셔야 하는 중요한 사항은, 이미지에서 파생된 (종료 상태를 포함한) 컨테이너가 하나라도 남아있다면 이미지는 삭제할 수 없습니다. 따라서 먼저 컨테이너를 종료하고, 삭제까지 해주어야합니다. docker rm은 컨테이너를 삭제하는 명령어이고, docker rmi는 이미지를 삭제하는 명령어입니다. 이 두 명령어를 혼동하지 않아야합니다.

## 도커와 버전 관리 시스템
### 컨테이너를 지지고 볶고 삶고 데치고 해도, 이미지에는 아무런 변화도 생기지 않습니다.
아주 간단한 예를 들어보자면, 윈도우 CD로 윈도우를 설치해서 사용한다고 설치한 윈도우 CD에 어떤 변화가 생기지는 않는 것과 같은 이치입니다. 이미지는 어디까지나 고정되어있습니다. 도커에서 이미지는 불변Immutable한 저장 매체입니다. 

## Dockerfile로 이미지 만들기 ( Dockerfile을 빌드하는 방법 )
Dockerfile은 도커만의 특별한 DSL로 이미지를 정의하는 파일입니다.

* 애플리케이션 실행을 위해 도커 이미지를 만드는 작업을 도커라이징Dockerizing이라고도 합니다.
  
        RUN apt-get update &&\
        apt-get -qq -y install git curl build-essential apache2 php5 libapache2-mod-php5 rcs

RUN은 직접 명령어를 실행하는 지시자입니다. RUN 바로 뒤에 명령어가 실행됩니다. 위의 두줄은 모니위키 실행을 위한 우분투 패키지들을 설치하는 명령어입니다. 여기서 사용한 RUN 명령어는 두 개의 명령어를 두 줄로 작성했습니다. RUN 명령어를 두 개로 명령어를 하나씩 실행해도 무방합니다. 이 글에서 자세히 다루지는 않지만 Dockerfile의 한 줄 한 줄은 레이어라는 형태로 저장되기 때문에 RUN을 줄이면 레이어가 줄어들고, 캐시도 효율적으로 관리할 수 있습니다. 여기서 &&은 여러 명령어를 이어서 실행하기 위한 연산자이고, \은 명령어를 여러줄에 작성하기 위한 문자입니다. 이는 Dockerfile을 작성할 때 자주 사용되는 패턴이니, 여러 명령어를 이어 붙일 때 RUN 하나에 &&\로 나눠 여러 명령어를 실행하는 데 사용한다고 기억해두면 도움이 됩니다.

    $ docker run -d -p 9999:80 nacyot/moniwiki:latest
    746443ad118afdb3f254eedaeeada5abc2b125c7263bc5e67c2964b570166187

docker run 입니다. 이번에는 -d와 -p 플래그를 사용합니다. 앞서서 자세히 설명하진 않았습니다만, -d 플래그는 -i의 반대 역할을 하는 옵션으로, 컨테이너를 백그라운드에서 실행합니다. -p는 포트포워딩을 지정하는 옵션입니다. :을 경계로 앞에는 외부 포트, 뒤에는 컨테이너 내부 포트를 지정합니다. 참고로 컨테이너 안에서 아파치가 80포트로 실행됩니다. 따라서 여기서는 9999로 들어오는 연결을 컨테이너에서 실행된 서버의 80포트로 보냅니다.

### 도커파일 작성 팁
Dockerfile을 처음부터 완성하기보다는 중간중간 빌드하면서 작업하는 것을 추천드립니다. 도커는 도커 이미지 빌드 과정을 캐시하기 때문에 내용이 변하지 않은 부분까지는 빠르게 빌드가 이루어집니다. 하지만 여전히 쉬운 과정은 아닙니다. 빌드만으로 어렵다면, 직접 이미지에 들어가서 작업을 해보는 것도 추천합니다. 예를 들어 베이스 이미지의 bash 셸을 실행해서 프로비저닝 작업을 수행해봅니다. 그리고 필요한 명령어나 지시자들을 Dockerfile로 작성하면 좀 더 수월한 편입니다.

## 도커의 이미지 빌드 과정
즉, 스탭 하나를 빌드할 때마다, 1. 컨테이너 생성, 2. 지시자 실행, 3. 임시 이미지 생성 과정을 거칩니다. 이 과정을 Dockerfile의 지시자수(즉, 스탭 수)만큼 반복합니다.
이 과정에서 생성된 중간 이미지들은 docker history 명령어로 확인할 수 있습니다.

## 실전: 도커 이미지로 서버 애플리케이션 배포하기

### 프로비저닝
어떤 애플리케이션을 서버에서 운영하려면 프로비저닝 과정을 거쳐야 합니다. 프로비저닝은 서버의 환경을 어떤 애플리케이션이 실행가능한 상태로 준비하는 과정을 의미합니다. 

물론 도커를 사용한다고 프로비저닝 과정 자체가 없어지지는 않습니다. 앞서 Dockerfile을 작성하고 이미지를 만드는 게 도커에서는 프로비저닝 작업이라고 할 수 있습니다. 프로비저닝을 어렵게 만드는 어려운 요소는 서버 환경이 동일하지 않다는 점과 서버 환경이 지속적으로 변화한다는 점입니다. 도커는 바로 이 문제를 해결해줍니다. 도커만 있으면 미리 준비한 이미지를 실행할 수 있기 때문에 리눅스 계열이라면 서버 환경에 크게 구애받지 않습니다. 또한 컨테이너로 실행되는 독자적인 환경을 가지고 있기 때문에 서버의 변화에도 거의 영향을 받지 않습니다. 과거에 만들어둔 이미지가 있다면, 대부분의 경우 잘 동작합니다.*

### 도커 허브에 이미지 올리기
docker login 하고 그냥 github 에서 하듯이 진행

### 디지털오션(Digital Ocean)에서 도커로 모니위키 컨테이너 실행
aws 에서 하는거랑 똑같.

    $ curl -s https://get.docker.com | sudo sh
    $ docker --version

docker 설치하고 컨테이너 실행 ㄱㄱ

    $ docker run -d -p 9999:80 <DOCKER_HUB_ID>/moniwiki:latest
    $ docker ps

 # 기타 ( 내 생각 )
EC2 인스턴스에 올릴 작업을 로컬에서 docker 안에서 실행하여 테스트하고
EC2 인스턴스에서는 도커 이미지를 이용하여 실행한 컨테이너(프로세스)를 통해 그 환경 안에서 작업을 진행하는 것은? 이렇게 하는 것이 큰 규모로 넘어갈 때는 도움이 되겠다는 생각.

git 과 비슷한 (거의 동일한) 커맨드들을 사용하여, 이미지간 계층 구조를 활용.

# 다음에 읽어볼 글 _ 컨테이너 오케스트레이션
쿠버네티스
https://subicura.com/2019/05/19/kubernetes-basic-1.html